{"ast":null,"code":"/*!\n * chartjs-plugin-streaming v2.0.0\n * https://nagix.github.io/chartjs-plugin-streaming\n * (c) 2017-2021 Akihiko Kusanagi\n * Released under the MIT license\n */\nimport { registry, TimeScale, defaults, DatasetController, Chart } from 'chart.js';\nimport { valueOrDefault, each, requestAnimFrame, callback, noop, isFinite, clipArea, unclipArea, isNumber, _lookup, isArray, getRelativePosition } from 'chart.js/helpers';\n\nfunction clamp(value, lower, upper) {\n  return Math.min(Math.max(value, lower), upper);\n}\n\nfunction resolveOption(scale, key) {\n  const realtimeOpts = scale.options.realtime;\n  const streamingOpts = scale.chart.options.plugins.streaming;\n  return valueOrDefault(realtimeOpts[key], streamingOpts[key]);\n}\n\nfunction getAxisMap(element, {\n  x,\n  y\n}, {\n  xAxisID,\n  yAxisID\n}) {\n  const axisMap = {};\n  each(x, key => {\n    axisMap[key] = {\n      axisId: xAxisID\n    };\n  });\n  each(y, key => {\n    axisMap[key] = {\n      axisId: yAxisID\n    };\n  });\n  return axisMap;\n}\n\nconst cancelAnimFrame = function () {\n  if (typeof window === 'undefined') {\n    return noop;\n  }\n\n  return window.cancelAnimationFrame;\n}();\n\nfunction startFrameRefreshTimer(context, func) {\n  if (!context.frameRequestID) {\n    const refresh = () => {\n      const nextRefresh = context.nextRefresh || 0;\n      const now = Date.now();\n\n      if (nextRefresh <= now) {\n        const newFrameRate = callback(func);\n        const frameDuration = 1000 / (Math.max(newFrameRate, 0) || 30);\n        const newNextRefresh = context.nextRefresh + frameDuration || 0;\n        context.nextRefresh = newNextRefresh > now ? newNextRefresh : now + frameDuration;\n      }\n\n      context.frameRequestID = requestAnimFrame.call(window, refresh);\n    };\n\n    context.frameRequestID = requestAnimFrame.call(window, refresh);\n  }\n}\n\nfunction stopFrameRefreshTimer(context) {\n  const frameRequestID = context.frameRequestID;\n\n  if (frameRequestID) {\n    cancelAnimFrame.call(window, frameRequestID);\n    delete context.frameRequestID;\n  }\n}\n\nfunction stopDataRefreshTimer(context) {\n  const refreshTimerID = context.refreshTimerID;\n\n  if (refreshTimerID) {\n    clearInterval(refreshTimerID);\n    delete context.refreshTimerID;\n    delete context.refreshInterval;\n  }\n}\n\nfunction startDataRefreshTimer(context, func, interval) {\n  if (!context.refreshTimerID) {\n    context.refreshTimerID = setInterval(() => {\n      const newInterval = callback(func);\n\n      if (context.refreshInterval !== newInterval && !isNaN(newInterval)) {\n        stopDataRefreshTimer(context);\n        startDataRefreshTimer(context, func, newInterval);\n      }\n    }, interval || 0);\n    context.refreshInterval = interval || 0;\n  }\n}\n\nfunction scaleValue(scale, value, fallback) {\n  value = typeof value === 'number' ? value : scale.parse(value);\n  return isFinite(value) ? {\n    value: scale.getPixelForValue(value),\n    transitionable: true\n  } : {\n    value: fallback\n  };\n}\n\nfunction updateBoxAnnotation(element, chart, options) {\n  const {\n    scales,\n    chartArea\n  } = chart;\n  const {\n    xScaleID,\n    yScaleID,\n    xMin,\n    xMax,\n    yMin,\n    yMax\n  } = options;\n  const xScale = scales[xScaleID];\n  const yScale = scales[yScaleID];\n  const {\n    top,\n    left,\n    bottom,\n    right\n  } = chartArea;\n  const streaming = element.$streaming = {};\n\n  if (xScale) {\n    const min = scaleValue(xScale, xMin, left);\n    const max = scaleValue(xScale, xMax, right);\n    const reverse = min.value > max.value;\n\n    if (min.transitionable) {\n      streaming[reverse ? 'x2' : 'x'] = {\n        axisId: xScaleID\n      };\n    }\n\n    if (max.transitionable) {\n      streaming[reverse ? 'x' : 'x2'] = {\n        axisId: xScaleID\n      };\n    }\n\n    if (min.transitionable !== max.transitionable) {\n      streaming.width = {\n        axisId: xScaleID,\n        reverse: min.transitionable\n      };\n    }\n  }\n\n  if (yScale) {\n    const min = scaleValue(yScale, yMin, top);\n    const max = scaleValue(yScale, yMax, bottom);\n    const reverse = min.value > max.value;\n\n    if (min.transitionable) {\n      streaming[reverse ? 'y2' : 'y'] = {\n        axisId: yScaleID\n      };\n    }\n\n    if (max.transitionable) {\n      streaming[reverse ? 'y' : 'y2'] = {\n        axisId: yScaleID\n      };\n    }\n\n    if (min.transitionable !== max.transitionable) {\n      streaming.height = {\n        axisId: yScaleID,\n        reverse: min.transitionable\n      };\n    }\n  }\n}\n\nfunction updateLineAnnotation(element, chart, options) {\n  const {\n    scales,\n    chartArea\n  } = chart;\n  const {\n    scaleID,\n    value\n  } = options;\n  const scale = scales[scaleID];\n  const {\n    top,\n    left,\n    bottom,\n    right\n  } = chartArea;\n  const streaming = element.$streaming = {};\n\n  if (scale) {\n    const isHorizontal = scale.isHorizontal();\n    const pixel = scaleValue(scale, value);\n\n    if (pixel.transitionable) {\n      streaming[isHorizontal ? 'x' : 'y'] = {\n        axisId: scaleID\n      };\n      streaming[isHorizontal ? 'x2' : 'y2'] = {\n        axisId: scaleID\n      };\n    }\n\n    return isHorizontal ? {\n      top,\n      bottom\n    } : {\n      left,\n      right\n    };\n  }\n\n  const {\n    xScaleID,\n    yScaleID,\n    xMin,\n    xMax,\n    yMin,\n    yMax\n  } = options;\n  const xScale = scales[xScaleID];\n  const yScale = scales[yScaleID];\n  const clip = {};\n\n  if (xScale) {\n    const min = scaleValue(xScale, xMin);\n    const max = scaleValue(xScale, xMax);\n\n    if (min.transitionable) {\n      streaming.x = {\n        axisId: xScaleID\n      };\n    } else {\n      clip.left = left;\n    }\n\n    if (max.transitionable) {\n      streaming.x2 = {\n        axisId: xScaleID\n      };\n    } else {\n      clip.right = right;\n    }\n  }\n\n  if (yScale) {\n    const min = scaleValue(yScale, yMin);\n    const max = scaleValue(yScale, yMax);\n\n    if (min.transitionable) {\n      streaming.y = {\n        axisId: yScaleID\n      };\n    } else {\n      clip.top = top;\n    }\n\n    if (max.transitionable) {\n      streaming.y2 = {\n        axisId: yScaleID\n      };\n    } else {\n      clip.bottom = bottom;\n    }\n  }\n\n  return clip;\n}\n\nfunction updatePointAnnotation(element, chart, options) {\n  const scales = chart.scales;\n  const {\n    xScaleID,\n    yScaleID,\n    xValue,\n    yValue\n  } = options;\n  const xScale = scales[xScaleID];\n  const yScale = scales[yScaleID];\n  const streaming = element.$streaming = {};\n\n  if (xScale) {\n    const x = scaleValue(xScale, xValue);\n\n    if (x.transitionable) {\n      streaming.x = {\n        axisId: xScaleID\n      };\n    }\n  }\n\n  if (yScale) {\n    const y = scaleValue(yScale, yValue);\n\n    if (y.transitionable) {\n      streaming.y = {\n        axisId: yScaleID\n      };\n    }\n  }\n}\n\nfunction initAnnotationPlugin() {\n  const BoxAnnotation = registry.getElement('boxAnnotation');\n  const LineAnnotation = registry.getElement('lineAnnotation');\n  const PointAnnotation = registry.getElement('pointAnnotation');\n  const resolveBoxAnnotationProperties = BoxAnnotation.prototype.resolveElementProperties;\n  const resolveLineAnnotationProperties = LineAnnotation.prototype.resolveElementProperties;\n  const resolvePointAnnotationProperties = PointAnnotation.prototype.resolveElementProperties;\n\n  BoxAnnotation.prototype.resolveElementProperties = function (chart, options) {\n    updateBoxAnnotation(this, chart, options);\n    return resolveBoxAnnotationProperties.call(this, chart, options);\n  };\n\n  LineAnnotation.prototype.resolveElementProperties = function (chart, options) {\n    const chartArea = chart.chartArea;\n    chart.chartArea = updateLineAnnotation(this, chart, options);\n    const properties = resolveLineAnnotationProperties.call(this, chart, options);\n    chart.chartArea = chartArea;\n    return properties;\n  };\n\n  PointAnnotation.prototype.resolveElementProperties = function (chart, options) {\n    updatePointAnnotation(this, chart, options);\n    return resolvePointAnnotationProperties.call(this, chart, options);\n  };\n}\n\nfunction attachChart$1(plugin, chart) {\n  const streaming = chart.$streaming;\n\n  if (streaming.annotationPlugin !== plugin) {\n    const afterUpdate = plugin.afterUpdate;\n    initAnnotationPlugin();\n    streaming.annotationPlugin = plugin;\n\n    plugin.afterUpdate = (_chart, args, options) => {\n      const mode = args.mode;\n      const animationOpts = options.animation;\n\n      if (mode === 'quiet') {\n        options.animation = false;\n      }\n\n      afterUpdate.call(this, _chart, args, options);\n\n      if (mode === 'quiet') {\n        options.animation = animationOpts;\n      }\n    };\n  }\n}\n\nfunction getElements(chart) {\n  const plugin = chart.$streaming.annotationPlugin;\n\n  if (plugin) {\n    const state = plugin._getState(chart);\n\n    return state && state.elements || [];\n  }\n\n  return [];\n}\n\nfunction detachChart$1(chart) {\n  delete chart.$streaming.annotationPlugin;\n}\n\nconst transitionKeys$1 = {\n  x: ['x', 'caretX'],\n  y: ['y', 'caretY']\n};\n\nfunction update$1(...args) {\n  const me = this;\n  const element = me.getActiveElements()[0];\n\n  if (element) {\n    const meta = me._chart.getDatasetMeta(element.datasetIndex);\n\n    me.$streaming = getAxisMap(me, transitionKeys$1, meta);\n  } else {\n    me.$streaming = {};\n  }\n\n  me.constructor.prototype.update.call(me, ...args);\n}\n\nconst chartStates = new WeakMap();\n\nfunction getState(chart) {\n  let state = chartStates.get(chart);\n\n  if (!state) {\n    state = {\n      originalScaleOptions: {}\n    };\n    chartStates.set(chart, state);\n  }\n\n  return state;\n}\n\nfunction removeState(chart) {\n  chartStates.delete(chart);\n}\n\nfunction storeOriginalScaleOptions(chart) {\n  const {\n    originalScaleOptions\n  } = getState(chart);\n  const scales = chart.scales;\n  each(scales, scale => {\n    const id = scale.id;\n\n    if (!originalScaleOptions[id]) {\n      originalScaleOptions[id] = {\n        duration: resolveOption(scale, 'duration'),\n        delay: resolveOption(scale, 'delay')\n      };\n    }\n  });\n  each(originalScaleOptions, (opt, key) => {\n    if (!scales[key]) {\n      delete originalScaleOptions[key];\n    }\n  });\n  return originalScaleOptions;\n}\n\nfunction zoomRealTimeScale(scale, zoom, center, limits) {\n  const {\n    chart,\n    axis\n  } = scale;\n  const {\n    minDuration = 0,\n    maxDuration = Infinity,\n    minDelay = -Infinity,\n    maxDelay = Infinity\n  } = limits && limits[axis] || {};\n  const realtimeOpts = scale.options.realtime;\n  const duration = resolveOption(scale, 'duration');\n  const delay = resolveOption(scale, 'delay');\n  const newDuration = clamp(duration * (2 - zoom), minDuration, maxDuration);\n  let maxPercent, newDelay;\n  storeOriginalScaleOptions(chart);\n\n  if (scale.isHorizontal()) {\n    maxPercent = (scale.right - center.x) / (scale.right - scale.left);\n  } else {\n    maxPercent = (scale.bottom - center.y) / (scale.bottom - scale.top);\n  }\n\n  newDelay = delay + maxPercent * (duration - newDuration);\n  realtimeOpts.duration = newDuration;\n  realtimeOpts.delay = clamp(newDelay, minDelay, maxDelay);\n  return newDuration !== scale.max - scale.min;\n}\n\nfunction panRealTimeScale(scale, delta, limits) {\n  const {\n    chart,\n    axis\n  } = scale;\n  const {\n    minDelay = -Infinity,\n    maxDelay = Infinity\n  } = limits && limits[axis] || {};\n  const delay = resolveOption(scale, 'delay');\n  const newDelay = delay + (scale.getValueForPixel(delta) - scale.getValueForPixel(0));\n  storeOriginalScaleOptions(chart);\n  scale.options.realtime.delay = clamp(newDelay, minDelay, maxDelay);\n  return true;\n}\n\nfunction resetRealTimeScaleOptions(chart) {\n  const originalScaleOptions = storeOriginalScaleOptions(chart);\n  each(chart.scales, scale => {\n    const realtimeOptions = scale.options.realtime;\n\n    if (realtimeOptions) {\n      const original = originalScaleOptions[scale.id];\n\n      if (original) {\n        realtimeOptions.duration = original.duration;\n        realtimeOptions.delay = original.delay;\n      } else {\n        delete realtimeOptions.duration;\n        delete realtimeOptions.delay;\n      }\n    }\n  });\n}\n\nfunction initZoomPlugin(plugin) {\n  plugin.zoomFunctions.realtime = zoomRealTimeScale;\n  plugin.panFunctions.realtime = panRealTimeScale;\n}\n\nfunction attachChart(plugin, chart) {\n  const streaming = chart.$streaming;\n\n  if (streaming.zoomPlugin !== plugin) {\n    const resetZoom = streaming.resetZoom = chart.resetZoom;\n    initZoomPlugin(plugin);\n\n    chart.resetZoom = transition => {\n      resetRealTimeScaleOptions(chart);\n      resetZoom(transition);\n    };\n\n    streaming.zoomPlugin = plugin;\n  }\n}\n\nfunction detachChart(chart) {\n  const streaming = chart.$streaming;\n\n  if (streaming.zoomPlugin) {\n    chart.resetZoom = streaming.resetZoom;\n    removeState(chart);\n    delete streaming.resetZoom;\n    delete streaming.zoomPlugin;\n  }\n}\n\nconst INTERVALS = {\n  millisecond: {\n    common: true,\n    size: 1,\n    steps: [1, 2, 5, 10, 20, 50, 100, 250, 500]\n  },\n  second: {\n    common: true,\n    size: 1000,\n    steps: [1, 2, 5, 10, 15, 30]\n  },\n  minute: {\n    common: true,\n    size: 60000,\n    steps: [1, 2, 5, 10, 15, 30]\n  },\n  hour: {\n    common: true,\n    size: 3600000,\n    steps: [1, 2, 3, 6, 12]\n  },\n  day: {\n    common: true,\n    size: 86400000,\n    steps: [1, 2, 5]\n  },\n  week: {\n    common: false,\n    size: 604800000,\n    steps: [1, 2, 3, 4]\n  },\n  month: {\n    common: true,\n    size: 2.628e9,\n    steps: [1, 2, 3]\n  },\n  quarter: {\n    common: false,\n    size: 7.884e9,\n    steps: [1, 2, 3, 4]\n  },\n  year: {\n    common: true,\n    size: 3.154e10\n  }\n};\nconst UNITS = Object.keys(INTERVALS);\n\nfunction determineStepSize(min, max, unit, capacity) {\n  const range = max - min;\n  const {\n    size: milliseconds,\n    steps\n  } = INTERVALS[unit];\n  let factor;\n\n  if (!steps) {\n    return Math.ceil(range / (capacity * milliseconds));\n  }\n\n  for (let i = 0, ilen = steps.length; i < ilen; ++i) {\n    factor = steps[i];\n\n    if (Math.ceil(range / (milliseconds * factor)) <= capacity) {\n      break;\n    }\n  }\n\n  return factor;\n}\n\nfunction determineUnitForAutoTicks(minUnit, min, max, capacity) {\n  const range = max - min;\n  const ilen = UNITS.length;\n\n  for (let i = UNITS.indexOf(minUnit); i < ilen - 1; ++i) {\n    const {\n      common,\n      size,\n      steps\n    } = INTERVALS[UNITS[i]];\n    const factor = steps ? steps[steps.length - 1] : Number.MAX_SAFE_INTEGER;\n\n    if (common && Math.ceil(range / (factor * size)) <= capacity) {\n      return UNITS[i];\n    }\n  }\n\n  return UNITS[ilen - 1];\n}\n\nfunction determineMajorUnit(unit) {\n  for (let i = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i < ilen; ++i) {\n    if (INTERVALS[UNITS[i]].common) {\n      return UNITS[i];\n    }\n  }\n}\n\nfunction addTick(ticks, time, timestamps) {\n  if (!timestamps) {\n    ticks[time] = true;\n  } else if (timestamps.length) {\n    const {\n      lo,\n      hi\n    } = _lookup(timestamps, time);\n\n    const timestamp = timestamps[lo] >= time ? timestamps[lo] : timestamps[hi];\n    ticks[timestamp] = true;\n  }\n}\n\nconst datasetPropertyKeys = ['pointBackgroundColor', 'pointBorderColor', 'pointBorderWidth', 'pointRadius', 'pointRotation', 'pointStyle', 'pointHitRadius', 'pointHoverBackgroundColor', 'pointHoverBorderColor', 'pointHoverBorderWidth', 'pointHoverRadius', 'backgroundColor', 'borderColor', 'borderSkipped', 'borderWidth', 'hoverBackgroundColor', 'hoverBorderColor', 'hoverBorderWidth', 'hoverRadius', 'hitRadius', 'radius', 'rotation'];\n\nfunction clean(scale) {\n  const {\n    chart,\n    id,\n    max\n  } = scale;\n  const duration = resolveOption(scale, 'duration');\n  const delay = resolveOption(scale, 'delay');\n  const ttl = resolveOption(scale, 'ttl');\n  const pause = resolveOption(scale, 'pause');\n  const min = Date.now() - (isNaN(ttl) ? duration + delay : ttl);\n  let i, start, count, removalRange;\n  each(chart.data.datasets, (dataset, datasetIndex) => {\n    const meta = chart.getDatasetMeta(datasetIndex);\n    const axis = id === meta.xAxisID && 'x' || id === meta.yAxisID && 'y';\n\n    if (axis) {\n      const controller = meta.controller;\n      const data = dataset.data;\n      const length = data.length;\n\n      if (pause) {\n        for (i = 0; i < length; ++i) {\n          const point = controller.getParsed(i);\n\n          if (point && !(point[axis] < max)) {\n            break;\n          }\n        }\n\n        start = i + 2;\n      } else {\n        start = 0;\n      }\n\n      for (i = start; i < length; ++i) {\n        const point = controller.getParsed(i);\n\n        if (!point || !(point[axis] <= min)) {\n          break;\n        }\n      }\n\n      count = i - start;\n\n      if (isNaN(ttl)) {\n        count = Math.max(count - 2, 0);\n      }\n\n      data.splice(start, count);\n      each(datasetPropertyKeys, key => {\n        if (isArray(dataset[key])) {\n          dataset[key].splice(start, count);\n        }\n      });\n      each(dataset.datalabels, value => {\n        if (isArray(value)) {\n          value.splice(start, count);\n        }\n      });\n\n      if (typeof data[0] !== 'object') {\n        removalRange = {\n          start: start,\n          count: count\n        };\n      }\n\n      each(chart._active, (item, index) => {\n        if (item.datasetIndex === datasetIndex && item.index >= start) {\n          if (item.index >= start + count) {\n            item.index -= count;\n          } else {\n            chart._active.splice(index, 1);\n          }\n        }\n      }, null, true);\n    }\n  });\n\n  if (removalRange) {\n    chart.data.labels.splice(removalRange.start, removalRange.count);\n  }\n}\n\nfunction transition(element, id, translate) {\n  const animations = element.$animations || {};\n  each(element.$streaming, (item, key) => {\n    if (item.axisId === id) {\n      const delta = item.reverse ? -translate : translate;\n      const animation = animations[key];\n\n      if (isFinite(element[key])) {\n        element[key] -= delta;\n      }\n\n      if (animation) {\n        animation._from -= delta;\n        animation._to -= delta;\n      }\n    }\n  });\n}\n\nfunction scroll(scale) {\n  const {\n    chart,\n    id,\n    $realtime: realtime\n  } = scale;\n  const duration = resolveOption(scale, 'duration');\n  const delay = resolveOption(scale, 'delay');\n  const isHorizontal = scale.isHorizontal();\n  const length = isHorizontal ? scale.width : scale.height;\n  const now = Date.now();\n  const tooltip = chart.tooltip;\n  const annotations = getElements(chart);\n  let offset = length * (now - realtime.head) / duration;\n\n  if (isHorizontal === !!scale.options.reverse) {\n    offset = -offset;\n  }\n\n  each(chart.data.datasets, (dataset, datasetIndex) => {\n    const meta = chart.getDatasetMeta(datasetIndex);\n    const {\n      data: elements = [],\n      dataset: element\n    } = meta;\n\n    for (let i = 0, ilen = elements.length; i < ilen; ++i) {\n      transition(elements[i], id, offset);\n    }\n\n    if (element) {\n      transition(element, id, offset);\n      delete element._path;\n    }\n  });\n\n  for (let i = 0, ilen = annotations.length; i < ilen; ++i) {\n    transition(annotations[i], id, offset);\n  }\n\n  if (tooltip) {\n    transition(tooltip, id, offset);\n  }\n\n  scale.max = now - delay;\n  scale.min = scale.max - duration;\n  realtime.head = now;\n}\n\nclass RealTimeScale extends TimeScale {\n  constructor(props) {\n    super(props);\n    this.$realtime = this.$realtime || {};\n  }\n\n  init(scaleOpts, opts) {\n    const me = this;\n    super.init(scaleOpts, opts);\n    startDataRefreshTimer(me.$realtime, () => {\n      const chart = me.chart;\n      const onRefresh = resolveOption(me, 'onRefresh');\n      callback(onRefresh, [chart], me);\n      clean(me);\n      chart.update('quiet');\n      return resolveOption(me, 'refresh');\n    });\n  }\n\n  update(maxWidth, maxHeight, margins) {\n    const me = this;\n    const {\n      $realtime: realtime,\n      options\n    } = me;\n    const {\n      bounds,\n      offset,\n      ticks: ticksOpts\n    } = options;\n    const {\n      autoSkip,\n      source,\n      major: majorTicksOpts\n    } = ticksOpts;\n    const majorEnabled = majorTicksOpts.enabled;\n\n    if (resolveOption(me, 'pause')) {\n      stopFrameRefreshTimer(realtime);\n    } else {\n      if (!realtime.frameRequestID) {\n        realtime.head = Date.now();\n      }\n\n      startFrameRefreshTimer(realtime, () => {\n        const chart = me.chart;\n        const streaming = chart.$streaming;\n        scroll(me);\n\n        if (streaming) {\n          callback(streaming.render, [chart]);\n        }\n\n        return resolveOption(me, 'frameRate');\n      });\n    }\n\n    options.bounds = undefined;\n    options.offset = false;\n    ticksOpts.autoSkip = false;\n    ticksOpts.source = source === 'auto' ? '' : source;\n    majorTicksOpts.enabled = true;\n    super.update(maxWidth, maxHeight, margins);\n    options.bounds = bounds;\n    options.offset = offset;\n    ticksOpts.autoSkip = autoSkip;\n    ticksOpts.source = source;\n    majorTicksOpts.enabled = majorEnabled;\n  }\n\n  buildTicks() {\n    const me = this;\n    const duration = resolveOption(me, 'duration');\n    const delay = resolveOption(me, 'delay');\n    const max = me.$realtime.head - delay;\n    const min = max - duration;\n    const maxArray = [1e15, max];\n    const minArray = [-1e15, min];\n    Object.defineProperty(me, 'min', {\n      get: () => minArray.shift(),\n      set: noop\n    });\n    Object.defineProperty(me, 'max', {\n      get: () => maxArray.shift(),\n      set: noop\n    });\n    const ticks = super.buildTicks();\n    delete me.min;\n    delete me.max;\n    me.min = min;\n    me.max = max;\n    return ticks;\n  }\n\n  calculateLabelRotation() {\n    const ticksOpts = this.options.ticks;\n    const maxRotation = ticksOpts.maxRotation;\n    ticksOpts.maxRotation = ticksOpts.minRotation || 0;\n    super.calculateLabelRotation();\n    ticksOpts.maxRotation = maxRotation;\n  }\n\n  fit() {\n    const me = this;\n    const options = me.options;\n    super.fit();\n\n    if (options.ticks.display && options.display && me.isHorizontal()) {\n      me.paddingLeft = 3;\n      me.paddingRight = 3;\n\n      me._handleMargins();\n    }\n  }\n\n  draw(chartArea) {\n    const me = this;\n    const {\n      chart,\n      ctx\n    } = me;\n    const area = me.isHorizontal() ? {\n      left: chartArea.left,\n      top: 0,\n      right: chartArea.right,\n      bottom: chart.height\n    } : {\n      left: 0,\n      top: chartArea.top,\n      right: chart.width,\n      bottom: chartArea.bottom\n    };\n    me._gridLineItems = null;\n    me._labelItems = null;\n    clipArea(ctx, area);\n    super.draw(chartArea);\n    unclipArea(ctx);\n  }\n\n  destroy() {\n    const realtime = this.$realtime;\n    stopFrameRefreshTimer(realtime);\n    stopDataRefreshTimer(realtime);\n  }\n\n  _generate() {\n    const me = this;\n    const adapter = me._adapter;\n    const duration = resolveOption(me, 'duration');\n    const delay = resolveOption(me, 'delay');\n    const refresh = resolveOption(me, 'refresh');\n    const max = me.$realtime.head - delay;\n    const min = max - duration;\n\n    const capacity = me._getLabelCapacity(min);\n\n    const {\n      time: timeOpts,\n      ticks: ticksOpts\n    } = me.options;\n    const minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min, max, capacity);\n    const major = determineMajorUnit(minor);\n    const stepSize = timeOpts.stepSize || determineStepSize(min, max, minor, capacity);\n    const weekday = minor === 'week' ? timeOpts.isoWeekday : false;\n    const majorTicksEnabled = ticksOpts.major.enabled;\n    const hasWeekday = isNumber(weekday) || weekday === true;\n    const interval = INTERVALS[minor];\n    const ticks = {};\n    let first = min;\n    let time, count;\n\n    if (hasWeekday) {\n      first = +adapter.startOf(first, 'isoWeek', weekday);\n    }\n\n    first = +adapter.startOf(first, hasWeekday ? 'day' : minor);\n\n    if (adapter.diff(max, min, minor) > 100000 * stepSize) {\n      throw new Error(min + ' and ' + max + ' are too far apart with stepSize of ' + stepSize + ' ' + minor);\n    }\n\n    time = first;\n\n    if (majorTicksEnabled && major && !hasWeekday && !timeOpts.round) {\n      time = +adapter.startOf(time, major);\n      time = +adapter.add(time, ~~((first - time) / (interval.size * stepSize)) * stepSize, minor);\n    }\n\n    const timestamps = ticksOpts.source === 'data' && me.getDataTimestamps();\n\n    for (count = 0; time < max + refresh; time = +adapter.add(time, stepSize, minor), count++) {\n      addTick(ticks, time, timestamps);\n    }\n\n    if (time === max + refresh || count === 1) {\n      addTick(ticks, time, timestamps);\n    }\n\n    return Object.keys(ticks).sort((a, b) => a - b).map(x => +x);\n  }\n\n}\n\nRealTimeScale.id = 'realtime';\nRealTimeScale.defaults = {\n  bounds: 'data',\n  adapters: {},\n  time: {\n    parser: false,\n    unit: false,\n    round: false,\n    isoWeekday: false,\n    minUnit: 'millisecond',\n    displayFormats: {}\n  },\n  realtime: {},\n  ticks: {\n    autoSkip: false,\n    source: 'auto',\n    major: {\n      enabled: true\n    }\n  }\n};\ndefaults.describe('scale.realtime', {\n  _scriptable: name => name !== 'onRefresh'\n});\nvar version = \"2.0.0\";\ndefaults.set('transitions', {\n  quiet: {\n    animation: {\n      duration: 0\n    }\n  }\n});\nconst transitionKeys = {\n  x: ['x', 'cp1x', 'cp2x'],\n  y: ['y', 'cp1y', 'cp2y']\n};\n\nfunction update(mode) {\n  const me = this;\n\n  if (mode === 'quiet') {\n    each(me.data.datasets, (dataset, datasetIndex) => {\n      const controller = me.getDatasetMeta(datasetIndex).controller;\n\n      controller._setStyle = function (element, index, _mode, active) {\n        DatasetController.prototype._setStyle.call(this, element, index, 'quiet', active);\n      };\n    });\n  }\n\n  Chart.prototype.update.call(me, mode);\n\n  if (mode === 'quiet') {\n    each(me.data.datasets, (dataset, datasetIndex) => {\n      delete me.getDatasetMeta(datasetIndex).controller._setStyle;\n    });\n  }\n}\n\nfunction render(chart) {\n  const streaming = chart.$streaming;\n  chart.render();\n\n  if (streaming.lastMouseEvent) {\n    setTimeout(() => {\n      const lastMouseEvent = streaming.lastMouseEvent;\n\n      if (lastMouseEvent) {\n        chart._eventHandler(lastMouseEvent);\n      }\n    }, 0);\n  }\n}\n\nvar StreamingPlugin = {\n  id: 'streaming',\n  version,\n\n  beforeInit(chart) {\n    const streaming = chart.$streaming = chart.$streaming || {\n      render\n    };\n    const canvas = streaming.canvas = chart.canvas;\n\n    const mouseEventListener = streaming.mouseEventListener = event => {\n      const pos = getRelativePosition(event, chart);\n      streaming.lastMouseEvent = {\n        type: 'mousemove',\n        chart: chart,\n        native: event,\n        x: pos.x,\n        y: pos.y\n      };\n    };\n\n    canvas.addEventListener('mousedown', mouseEventListener);\n    canvas.addEventListener('mouseup', mouseEventListener);\n  },\n\n  afterInit(chart) {\n    chart.update = update;\n  },\n\n  beforeUpdate(chart) {\n    const {\n      scales,\n      elements\n    } = chart.options;\n    const tooltip = chart.tooltip;\n    each(scales, ({\n      type\n    }) => {\n      if (type === 'realtime') {\n        elements.line.capBezierPoints = false;\n      }\n    });\n\n    if (tooltip) {\n      tooltip.update = update$1;\n    }\n\n    try {\n      const plugin = registry.getPlugin('annotation');\n      attachChart$1(plugin, chart);\n    } catch (e) {\n      detachChart$1(chart);\n    }\n\n    try {\n      const plugin = registry.getPlugin('zoom');\n      attachChart(plugin, chart);\n    } catch (e) {\n      detachChart(chart);\n    }\n  },\n\n  beforeDatasetUpdate(chart, args) {\n    const {\n      meta,\n      mode\n    } = args;\n\n    if (mode === 'quiet') {\n      const {\n        controller,\n        $animations\n      } = meta;\n\n      if ($animations && $animations.visible && $animations.visible._active) {\n        controller.updateElement = noop;\n        controller.updateSharedOptions = noop;\n      }\n    }\n  },\n\n  afterDatasetUpdate(chart, args) {\n    const {\n      meta,\n      mode\n    } = args;\n    const {\n      data: elements = [],\n      dataset: element,\n      controller\n    } = meta;\n\n    for (let i = 0, ilen = elements.length; i < ilen; ++i) {\n      elements[i].$streaming = getAxisMap(elements[i], transitionKeys, meta);\n    }\n\n    if (element) {\n      element.$streaming = getAxisMap(element, transitionKeys, meta);\n    }\n\n    if (mode === 'quiet') {\n      delete controller.updateElement;\n      delete controller.updateSharedOptions;\n    }\n  },\n\n  beforeDatasetDraw(chart, args) {\n    const {\n      ctx,\n      chartArea,\n      width,\n      height\n    } = chart;\n    const {\n      xAxisID,\n      yAxisID,\n      controller\n    } = args.meta;\n    const area = {\n      left: 0,\n      top: 0,\n      right: width,\n      bottom: height\n    };\n\n    if (xAxisID && controller.getScaleForId(xAxisID) instanceof RealTimeScale) {\n      area.left = chartArea.left;\n      area.right = chartArea.right;\n    }\n\n    if (yAxisID && controller.getScaleForId(yAxisID) instanceof RealTimeScale) {\n      area.top = chartArea.top;\n      area.bottom = chartArea.bottom;\n    }\n\n    clipArea(ctx, area);\n  },\n\n  afterDatasetDraw(chart) {\n    unclipArea(chart.ctx);\n  },\n\n  beforeEvent(chart, args) {\n    const streaming = chart.$streaming;\n    const event = args.event;\n\n    if (event.type === 'mousemove') {\n      streaming.lastMouseEvent = event;\n    } else if (event.type === 'mouseout') {\n      delete streaming.lastMouseEvent;\n    }\n  },\n\n  destroy(chart) {\n    const {\n      scales,\n      $streaming: streaming,\n      tooltip\n    } = chart;\n    const {\n      canvas,\n      mouseEventListener\n    } = streaming;\n    delete chart.update;\n\n    if (tooltip) {\n      delete tooltip.update;\n    }\n\n    canvas.removeEventListener('mousedown', mouseEventListener);\n    canvas.removeEventListener('mouseup', mouseEventListener);\n    each(scales, scale => {\n      if (scale instanceof RealTimeScale) {\n        scale.destroy();\n      }\n    });\n  },\n\n  defaults: {\n    duration: 10000,\n    delay: 0,\n    frameRate: 30,\n    refresh: 1000,\n    onRefresh: null,\n    pause: false,\n    ttl: undefined\n  },\n  descriptors: {\n    _scriptable: name => name !== 'onRefresh'\n  }\n};\nconst registerables = [StreamingPlugin, RealTimeScale];\nexport default registerables;\nexport { RealTimeScale, StreamingPlugin };","map":null,"metadata":{},"sourceType":"module"}